#!/bin/zsh
#
# Project Home - Treat your home directory like it's a project. Share
# your environment across your shell accounts.
#
# I store projects as:
#     ~/src/PROJECT[-BRANCH]/
#
# When I am main-lining, -BRANCH is ommited. So I set PH_REPO to
# ~/src/home - since it is essentially a collection of files that are
# are in my home directory.
#

export PH_REPO=${PH_REPO:-$HOME/src/home}

[[ -d $PH_REPO ]] || {
    print "You must set PH_REPO to your repository location. $PH_REPO does not exist."
    return 1
}

usage()
{
    cat <<EOF
 Usage: $0 OPERATION [OPTIONS...]

    add FILE [FILE...]
       Move a file to the repository and symlink it.

    rm FILE [FILE...]
       Remove a file and symlinks.

    install
       Create all symlinks from $PH_REPO to $HOME. Run this once, or
       if symlinks break for some reason.

    show
       List the current files and link status. This is like an 'install'
       dry-run and can be piped to zsh to act like 'install'.

    clean
        Recurse in home directory and find broken symlinks to $PH_REPO.


EOF
    exit 1
}

ph_add()
{
    local cfile
    local file
    local file_tail
    local relative_dir
    local repo_dir

    for file in $*; do
        repo_dir="$PH_REPO"

        # canonicalize then remove ^$HOME/ so we're left with the relative path
        # to the file from $HOME.
        cfile=$(readlink -e $file)
        file=${cfile#$HOME/}
        file_tail=${file:t}

        # If the file is not in $HOME/ but instead a sub directory, identify
        # the equivalent sub directory in the repository and create it
        if [[ ${file:h} != "." ]]; then
            relative_dir="${file:h}/"
            repo_dir="$PH_REPO/${file:h}"
            mkdir -vp $repo_dir
        else
            relative_dir=""
        fi

        mv -v $cfile $repo_dir &&
		( cd $PH_REPO ; git add $relative_dir$file_tail ) &&
		ln -vfs $repo_dir/$file_tail $cfile
    done
}

ph_rm()
{
    local cfile
    local file
    local relative_dir
    local file_tail

    for file in $*; do
        cfile=$(readlink -e $file)
        file=${cfile#$HOME/}
        file_tail=${file:t}
        if [[ ${file:h} != "." ]]; then
            relative_dir="${file:h}/"
        fi
        ( cd $PH_REPO ; git rm $relative_dir$file_tail )
        rm -vf $HOME/$file
    done
}

ph_install()
{
    local file

    setopt localoptions globdots extendedglob
    pushd $PH_REPO

    # Symlink every file to home dir
    for file in (^.git/)#*(.); do
        # determine target directory of file
        dir=${file:h}

        # Make directory when it doesn't exist
        mkdir -p $HOME/$dir
        ln -vfs $PWD/$file $HOME/$file
    done
    popd
}

ph_show ()
{
    local file
    local exists

    setopt localoptions globdots extendedglob
    pushd $PH_REPO

    # Symlink every file to home dir
    for file in (^.git/)#*(.); do
        # determine target directory of file
        dir=${file:h}

        # Make directory when it doesn't exist
        if [[ -d $HOME/$dir ]]; then
            print "# dir already exists $HOME/$dir"
        else
            print "mkdir -p $HOME/$dir"
        fi

        exists=false
        if [[ -L $HOME/$file ]]; then
            [[ $(readlink $HOME/$file) = "$PWD/$file" ]] && exists=true
        fi

        if $exists; then
            print "# link already exists for $PWD/$file"
        else
            print "ln -vfs $PWD/$file $HOME/$file"
        fi
    done
    popd
}

ph_clean()
{
    local file
    local dir
    local dest

    setopt localoptions globdots extendedglob
    pushd $PH_REPO

    # Symlink every file to home dir
    for file in $(find $HOME -xtype l 2>/dev/null); do
        # determine target of file
        dest=$(readlink $file)

        # If it links into the home repository remove it
        if [[ $dest == $PH_REPO* ]]; then
            print "rm -f \"$file\""
        fi
    done
    popd
}

command=$1
whence ph_$command >/dev/null || usage
ph_$command $*[2,-1]
