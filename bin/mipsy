#!/usr/bin/env python
'''
Usage: mipsy

Instruction decoding -- See also the structs in the mips_instruction union in
linux/arch/mips/include/asm/inst.h
'''

import sys
import collections

Instr = collections.namedtuple('Instr', 'mneumonic meaning optype opcode funct')

# op Type Not Available
TNA = 0

INSTRUCTIONS = {
    Instr('add', 'Add', 'R', 0x00, 0x20),
    Instr('addi', 'Add Immediate', 'I', 0x08, TNA),
    Instr('addiu', 'Add Unsigned Immediate', 'I', 0x09, TNA),
    Instr('addu', 'Add Unsigned', 'R', 0x00, 0x21),
    Instr('and', 'Bitwise AND', 'R', 0x00, 0x24),
    Instr('andi', 'Bitwise AND Immediate', 'I', 0x0C, TNA),
    Instr('beq', 'Branch if Equal', 'I', 0x04, TNA),
    Instr('bne', 'Branch if Not Equal', 'I', 0x05, TNA),
    Instr('div', 'Divide', 'R', 0x00, 0x1A),
    Instr('divu', 'Unsigned Divide', 'R', 0x00, 0x1B),
    Instr('j', 'Jump to Address', 'J', 0x02, TNA),
    Instr('jal', 'Jump and Link', 'J', 0x03, TNA),

    Instr('sll', 'Logical Shift Left', 'R', 0x00, 0x00),
    Instr('srl', 'Logical Shift Right (0-extended)', 'R', 0x00, 0x02),
    Instr('sra', 'Arithmetic Shift Right (sign-extended)', 'R', 0x00, 0x03),

    Instr('sllv', '', 'R', 0x00, 0x04),
    Instr('srlv', '', 'R', 0x00, 0x06),
    Instr('srav', '', 'R', 0x00, 0x07),

    Instr('jr', 'Jump to Address in Register', 'R', 0x00, 0x08),
    Instr('jalr', '', 'R', 0x00, 0x09),
    Instr('movz', '', 'R', 0x00, 0x0a),
    Instr('movn', '', 'R', 0x00, 0x0b),
    Instr('syscall', '', 'R', 0x00, 0xc),
    Instr('break', '', 'R', 0x00, 0xd),
    Instr('sync', '', 'R', 0x00, 0xf),
    Instr('sub', 'Subtract', 'R', 0x00, 0x22),
    Instr('subu', 'Unsigned Subtract', 'R', 0x00, 0x23),

    Instr('mfhi', 'Move from HI Register', 'R', 0x00, 0x10),
    Instr('mflo', 'Move from LO Register', 'R', 0x00, 0x12),
    Instr('lbu', 'Load Byte Unsigned', 'I', 0x24, TNA),
    Instr('lhu', 'Load Halfword Unsigned', 'I', 0x25, TNA),
    Instr('lui', 'Load Upper Immediate', 'I', 0x0F, TNA),
    Instr('lw', 'Load Word', 'I', 0x23, TNA),
    Instr('mfc0', 'Move from Coprocessor 0', 'R', 0x10, TNA),
    Instr('mult', 'Multiply', 'R', 0x00, 0x18),
    Instr('multu', 'Unsigned Multiply', 'R', 0x00, 0x19),
    Instr('xor', 'Bitwise XOR (Exclusive-OR)', 'R', 0x00, 0x26),
    Instr('nor', 'Bitwise NOR (NOT-OR)', 'R', 0x00, 0x27),
    Instr('or', 'Bitwise OR', 'R', 0x00, 0x25),
    Instr('ori', 'Bitwise OR Immediate', 'I', 0x0D, TNA),
    Instr('sb', 'Store Byte', 'I', 0x28, TNA),
    Instr('sh', 'Store Halfword', 'I', 0x29, TNA),
    Instr('slt', 'Set to 1 if Less Than', 'R', 0x00, 0x2A),
    Instr('slti', 'Set to 1 if Less Than Immediate', 'I', 0x0A, TNA),
    Instr('sltiu', 'Set to 1 if Less Than Unsigned Immediate', 'I', 0x0B, TNA),
    Instr('sltu', 'Set to 1 if Less Than Unsigned', 'R', 0x00, 0x2B),
    Instr('sw', 'Store Word', 'I', 0x2B, TNA),

    #Instr('move', '', 'R', 0x00, 0x2d),
    Instr('daddu', '', 'R', 0x00, 0x2d),

    Instr('tge', '', 'R', 0x00, 0x30),
    Instr('tgeu', '', 'R', 0x00, 0x31),
    Instr('tlt', '', 'R', 0x00, 0x32),
    Instr('tltu', '', 'R', 0x00, 0x33),
    Instr('teq', '', 'R', 0x00, 0x34),
    Instr('tne', '', 'R', 0x00, 0x36),

    Instr('sd', 'Store Doubleword', 'I', 0x3f, TNA),
}

#
# MIPS 64-bit memory map
# It's packed inside of a 32-bit memory map. When emulating the 32-bit
# instruction set, regs contain the 64-bit signed extension. This gives
# access to the upper and lower 2G of the map.
#

MMAP = (
    (0xffffffffffffffff, 'xkseg: mapped kseg2 (supervisor) top'),
    (0xffffffffe0000000, 'xkseg: mapped kseg2 (supervisor)'),
    (0xffffffffc0000000, 'xkseg: mapped kseg2 (kernel)'),
    (0xffffffffa0000000, ('xkseg: "unmapped" uncached kseg1'
                          'used for bootrom, IO regs'
                          'top bit is stripped to get phys addr')),
    (0xffffffff80000000, ('xkseg: "unmapped" cached kseg0'
                          'Exception handlers; in cache for performance'
                          'Bottom of reachable xkseg with 32-bit pointers'
                          'top bit is stripped to get phys addr')),
    (0xc00000ffffffffff, 'xkseg: kernel accessible'),
    (0xc000000000000000, 'xkseg: kernel accessible 2^40+'),
    (0x9800000000000000, 'xkphys: uncached window on phys'),
    (0x9000000000000000, 'xkphys: cached window on phys'),
    (0x8fffffffffffffff, 'xsseg: top'),
    (0x4000000000000000, 'xsseg: supervisor accessible 2^40+'),
    (0x3fffffffffffffff, 'xuseg: top'),
    (0x0000000080000000, 'xuseg: only accessible with 64-bit pointers)'),
    (0x000000007fffffff, 'xuseg: top of 32-bit accessible'),
    (0x0000000000000000, 'xuseg: bottom'),
)

MMAPLINUX = (
    (0xffffffffffffffff, 'xkseg: mapped kseg2 top'),
    # Dynamically mapped kernel data
    # Kernel modules
    # Mapping for phys addr above 512 Mbytes
    (0xffffffffc0000000, 'xkseg: mapped kseg2'),
    (0xffffffffa0000000, ('xkseg: "unmapped" uncached kseg1'
                          'used for bootrom, IO regs'
                          'top bit is stripped to get phys addr')),
    (0xffffffff80000000, ('xkseg: "unmapped" cached kseg0'
                          'Exception handlers; in cache for performance'
                          'Bottom of reachable xkseg with 32-bit pointers'
                          'top bit is stripped to get phys addr')),
    (0xc00000ffffffffff, 'xkseg: kernel accessible'),
    (0xc000000000000000, 'xkseg: kernel accessible 2^40+'),
    (0x9800000000000000, 'xkphys: uncached window on phys'),
    (0x9000000000000000, 'xkphys: cached window on phys'),
    (0x8fffffffffffffff, 'xsseg: top'),
    (0x4000000000000000, 'xsseg: supervisor accessible 2^40+'),
    (0x3fffffffffffffff, 'xuseg: top'),
    (0x0000000080000000, 'xuseg: only accessible with 64-bit pointers)'),
    (0x000000007fffffff, 'xuseg: top of 32-bit accessible'),
    (0x0000000000000000, 'xuseg: bottom'),
)


def decode_instr(optbl, word):
    """ Decode the instruction word with the table optbl.
    """
    # Bits 31:26 represent the op code
    opcode = (word >> 26)
    try:
        instr = optbl[opcode]
    except KeyError:
        print "No instruction for opcode=0x%02x" % (opcode, )
        return

    # Above we validated op types. If it's a dict it's an R type and requires
    # function bites to do the lookup.
    if type(instr) is dict:
        funct = word & 0x3f
        # print "looking up 0x%02x in dict" % (funct, )
        try:
            instr = instr[funct]
        except KeyError:
            print "No instruction for opcode=0x00 func=0x%02x" % (funct, )
            return

    print ("0x%08x opcode=0x%02x type=%s mnemonic=%s meaning=%s" %
           (word, instr.opcode, instr.optype, instr.mneumonic, instr.meaning))
    indent = ' ' * 10

    if instr.optype == 'R':
        # Type-R register-to-register
        # rs 25:21 5 bits
        # rt 20:16 5 bits
        # rd 15:11 5 bits
        # shamt 10:6 5 bits
        # funct 5:0 6 bits (already in instr)
        shamt = (word >> 6) & 0x1f
        rrd = (word >> 11) & 0x1f
        rrt = (word >> 16) & 0x1f
        rrs = (word >> 21) & 0x1f

        print ("%s rs=0x%02x rt=0x%02x rd=0x%02x shamt=0x%02x funct=0x%02x" %
               (indent, rrs, rrt, rrd, shamt, instr.funct,))

    elif instr.optype == 'I':
        # Type-I register immediate
        # rs 25:21 5 bits
        # rt 20:16 5 bits
        # immediate 15:0
        irt = (word >> 16) & 0x1f
        irs = (word >> 21) & 0x1f
        immediate = word & 0xffff

        print "%s rs=0x%02x rt=0x%02x immediate=0x%04x" % (indent, irs, irt,
                                                           immediate,)

    elif instr.optype == 'J':
        # Type-J jump
        # address 25:0
        address = word & 0x03ffffff

        print "%s address=0x%08x" % (indent, address,)

def main():
    """ Main entry
    """
    optbl = {}
    for instr in INSTRUCTIONS:
        if instr.optype in ('I', 'J'):
            assert instr.funct == TNA
            if instr.opcode in optbl:
                print >> sys.stderr, ("opcode 0x%02x already in table %s" %
                                     (instr.opcode, optbl[instr.opcode]))
                return

            optbl[instr.opcode] = instr
        elif instr.optype == 'R':
            if instr.opcode not in optbl:
                optbl[instr.opcode] = {}

            #print "adding op 0x%02x funct 0x%02x" % (instr.opcode,
            #                                         instr.funct, )
            assert instr.funct not in optbl[instr.opcode]
            optbl[instr.opcode][instr.funct] = instr
        else:
            assert False

    for arg in sys.argv[1:]:
        word = int(arg, 16)
        decode_instr(optbl, word)

if __name__ == '__main__':
    main()
